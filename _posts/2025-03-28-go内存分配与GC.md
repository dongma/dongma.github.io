---
layout: post
title: Go内存分配与GC
---
### Go语言GMP介绍
> Go语言相比Java，有更好的并发能力（GMP模型），同时其占用的服务器资源也较少，了解一下GMP的理念。从操作系统层面来看，线程是指内核级线程，是操作系统最小调度单元，创建、销毁、调度交由内核完成，可充分利用多核。协程（用户线程）与线程存在`M:1`的映射关系，从属于同一个内存级线程，无法并行，并且，一个协程阻塞会导致从属同一线程的所有协程无法执行。

### Goroutine
经`Golang`优化后的协程，其有如下特点：1）与线程存在映射关系，为`M:N`；2）创建、销毁、调度在用户态完成，对内核透明，足够轻便；3）可利用多个线程，实现并行；4）通过调度器的斡旋，实现和线程间的动态绑定和灵活调度；5）栈空间大小可动态扩缩，因地制宜；

在`/runtime/proc.go`的代码注释中，有对`GMP`的解释，其核心数据结构在`/runtime/runtime2.go`:
<!-- more -->
- 其中`g`是`Golang`中对协程的抽象，`g`有自己的运行栈，状态及执行的任务函数，`g`需要绑定到`p`上才能执行，`p`就是`g`的`cpu`；
- `m`即`machine`，是`golang`中对线程的抽象，`m`不直接执行`g`，而是先和`p`绑定，由其代理执行；借由`p`的存在，`m`无需和`g`绑死，也无需记录`g`的状态信息，因此`g`在全生命周期中可以跨`m`执行。
- `p`也即`processor`，是`golang`中的调度器。对于`g`而言，`p`是其调度器，`g`只有被`p`调度，才得以执行；对`m`而言，`p`是其执行代理，为其提供必要信息的同时，隐藏了繁杂的调度细节；

```go
// Goroutine scheduler, Design doc at https://golang.org/s/go11sched.
// The scheduler's job is to distribute ready-to-run goroutines over worker threads.
//
// The main concepts are:
// G - goroutine.
// M - worker thread, or machine.
// P - processor, a resource that is required to execute Go code.
//     M must have an associated P to execute Go code, however it can be
//     blocked or in a syscall w/o an associated P.
```
`gmp`模型其要点和调度规则如下：
- `M`是线程的抽象；`G`是`goroutine`；`P`是承上启下的调度器；`M`调度`G`前，需要和`P`绑定；
- 全局有多个`M`和多个`P`，但同时并行的`G`的最大数量等于`P`的数量；
- `G`的存放队列有三类：`P`的本地队列、全局队列和`wait`队列（图中未展示，为io阻塞就绪态`goroutine`队列）；
- `M`调度`G`时，优先取`P`本地队列，其次取全局队列，最后取`wait`队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；
- 为防止不同P的闲忙差异过大，设立`work-stealing`机制，本地队列为空的`P`可以尝试从其他`P`本地队列偷取一半的`G`补充到自身队列;

### GMP调度
`g0`是一种特殊的调度协程，不执行用户函数，负责执行`g`之间的切换调度，与`m`的关系为`1:1`。`goroutine`的类型可分为两类：
- 1）负责调度普通`g`的`g0`，与`m`的关系为一对一；
- 2）负责执行用户函数的普通`g`，被调度执行的`g`永远在`g`和`g0`的状态间切换；

当`g0`找到可执行`g`时，会调用`gogo`方法，调度`g`执行用户定义的任务。当`g`需要主动让渡时，会触发`mcall`方法，将执行权限重新交给`g0`；

广义"调度"可分为几种类型：
- 主动调度：一种用户主动执行让渡过程，主要方式是在代码中执行`runtime.Gosched`方法(`runtime/proc.go`)，此时当前`g`会当让出执行权，主动进行队列等待下次被调度执行。
- 被动调度：因不满足某执行条件，`g`可能陷入阻塞态无法被调度，直到关注的条件达成后，`g`才从阻塞中被唤醒(对应`runtime/proc.go#gopark`方法，恢复则是`goready`方法)。
- 正常调度: `g`中的执行任务已完成，`g0`会将当前`g`置为死亡状态，发起新一轮调度；
- 抢占调度：倘若`g`执行系统调用超过指定的时长，且全局`p`资源比较短缺，此时将`p`和`g`接绑，用解绑的`p`用于其他`g`的调度；

值得一提的是，前`3`种调度方式都由`m`下的`g0`完成。而抢占调用则是由一个全局监控协程`monitor g`来监控，倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作。从宏观上：
- 以`g0` -> `g` -> `g0` 的一轮循环为例进行串联；
- `g0` 执行 `schedule()` 函数，寻找到用于执行的 `g`；
- `g0` 执行 `execute()` 方法，更新当前 `g`、`p` 的状态信息，并调用`gogo()`方法，将执行权交给`g`；
- `g` 因主动让渡(`gosche_m()`)、被动调度(`park_m()`)、正常结束(`goexit0()`)等原因，调用`m_call`函数，执行权重新回到`g0`手中；
- `g0`执行`schedule()`函数，开启新一轮循环.

`p`每执行`61`次，会从全局队列中获取一个`goroutine`进行执行，同时会额外将全局队列中的一个`goroutine`放到本地队列中。若本地队列已满，则会返回来将本地队列中一半的`g`放回全局队列中，帮助当前`p`缓解执行压力;

## Go内存模型与分配机制
> 在操作系统中，存在`寄存器`、`高速缓存`、`内存`和`磁盘`，越接近`cpu`存储的容量越小，其对应的价格就越高昂。页表、分页管理等机制来减少内存碎片。

`Golang`中的内存模型，以空间换时间，一次缓存，多次复用。堆`mheap`正是基于该思想，产生的数据结构。依次细化粒度，建立了 mcentral、mcache 的模型，下面对三者作个梳理：
- `mheap`：全局的内存起源，访问要加全局锁；
- `mcentral`：每种对象大小规格（全局共划分为`68`种）对应的缓存，锁的粒度也仅限于同一种规格以内；
- `mcache`：每个`P`（正是`GMP`中的`P`）持有一份的内存缓存，访问时无锁，多级规格，提高利用率；
<div>
    <img src="https://pic4.zhimg.com/v2-f1126996923c66a21902883b60eb278b_r.jpg" width="660"/>
</div>

### 内存单元`mspan`
`page`和`mspan`的`2`个概念，page：最小的存储单元，默认大小为`8KB`，`mspan`大小为`page`的整数倍，且从`8B`到`80`KB 被划分为`67`种不同的规格，对应源代码在`runtime/sizeclasses.go`，`mspan`具有如下特点：
- 根据规格大小，产生了等级的制度，`mspan`是`Golang`内存管理的最小单元，`runtime/mheap.go`；
- 消除了外部碎片，但不可避免会有内部碎片；
- 宏观上能提高整体空间利用率，同等级的`mspan`会从属同一个`mcentral`，最终会被组织成链表，因此带有前后指针（`prev`、`next`）；
- 正是因为有了规格等级的概念，才支持`mcentral`实现细锁化，全局总览，留个印象；
- `mspan`会基于`bitMap`辅助快速找到空闲内存块（块大小为对应等级下的`object`大小），此时需要使用到`Ctz64`算法.

<div>
    <img src="https://pic4.zhimg.com/v2-1a053695aa6f80692753800c92b5c76f_r.jpg" width="660"/>
</div>

### 线程缓存`mcache`
- `mcache`是每个`P`独有的缓存，因此交互无锁；
- `mcache`将每种`spanClass`等级的`mspan`各缓存了一个，总数为`2`（`nocan`维度） * `68`（大小维度）= `136`;
- `mcache`中还有一个为对象分配器`tiny allocator`，用于处理小于`16B`对象的内存分配；
<div>
    <img src="https://pic4.zhimg.com/v2-2ec4168fd9670e48c4c322c004cb5b3f_1440w.jpg" width="660"/>
</div>

### 中心缓存`mcentral`
要点:
- 每个`mcentral`对应一种`spanClass`；
- 每个`mcentral`下聚合了该`spanClass`下的`mspan`;
- `mcentral`下的`mspan`分为两个链表，分别为有空间`mspan`链表`partial`和满空间`mspan`链表`full``;
- 每个`mcentral`一把锁;
<div>
    <img src="https://pic2.zhimg.com/v2-f2af84fcc77d9fbe4506e93e25b7343b_1440w.jpg" width="465"/>
</div>

### 全局堆缓存`mheap`
- 对于`Golang`上层应用而言，堆是操作系统虚拟内存的抽象，以页（8KB）为单位，作为最小内存存储单元；
- 负责将连续页组装成`mspan`，全局内存基于`bitMap`标识其使用情况，每个`bit`对应一页，为`0`则自由，为`1`则已被`mspan`组装；
- 通过`heapArena`聚合页，记录了页到`mspan`的映射信息，建立空闲页基数树索引`radix tree index`，辅助快速寻找空闲页；
- 是`mcentral`的持有者，持有所有`spanClass`下的`mcentral`，作为自身的缓存，内存不够时，向操作系统申请，申请单位为 heapArena（64M）；

### 对象分配流程
不论是以下哪种方式，最终都会殊途同归步入`mallocgc`方法中，例如：`new(T)`、`&T{}`、`make(xxxx)`，`Golang`中，依据`object`的大小，会将其分为下述三类：`tiny`微对象(0, 16B)、`small`小对象(16B，32KB)、`large`大对象(32KB，正无穷).
对于微对象的分配流程：
1. 从`P`专属`mcache`的`tiny`分配器取内存（无锁）
2. 根据所属的`spanClass`，从`P`专属`mcache`缓存的`mspan`中取内存（无锁）
3. 根据所属的`spanClass`从对应的`mcentral`中取`mspan`填充到`mcache`，然后从`mspan`中取内存（`spanClass`粒度锁）；
4. 根据所属的`spanClass`，从`mheap`的页分配器`pageAlloc`取得足够数量空闲页组装成`mspan`填充到`mcache`，然后从`mspan`中取内存（全局锁）；
5. `mheap``向操作系统申请内存，更新页分配器的索引信息，然后重复（4）；

对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步； 对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步.

## Go垃圾回收原理
> 做`Java`的都对`GC`比较熟悉，在`JVM`中常见的`GC`算法有：标记整理（Mark-Sweep）、标记压缩（Mark-Compact）、半空间复制（类似于`G1`），通过引用计数寻找不可达对象，便于垃圾回收。
### `Go`中三色标记法
`Golang GC`中用到的三色标记法属于标记清扫-算法下的一种实现，由荷兰的计算机科学家`Dijkstra`提出，下面阐述要点：
- 对象分为三种颜色标记：黑、灰、白，黑对象代表，对象自身存活，且其指向对象都已标记完成；
- 灰对象代表，对象自身存活，但其指向对象还未标记完成；白对象代表，对象尙未被标记到，可能是垃圾对象
- 标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰；
- 标记规则是，从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑；
- 标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫；
<div>
    <img src="https://pic3.zhimg.com/v2-e5cfe71a2eb567f8681c8b9c6c3f71c0_r.jpg" width="660"/>
</div>

为了应对并发情况下，对象标记出现漏标、多标的情况，可使用屏障机制。漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 一套用于解决漏标问题的方法论称之为强弱三色不变式：
- 强三色不变式：白色对象不能被黑色对象直接引用;
- 弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）；
